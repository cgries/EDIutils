#' Make authentication key
#'
#' @description
#'     Create user authentication key for PASTA+ operations.
#'
#' @param user.id
#'     (character) Identification of user performing the evaluation.
#' @param affiliation
#'     (character) Affiliation corresponding with the user.id argument supplied
#'     above. Can be: 'LTER' or 'EDI'.
#'
auth_key <- function(user.id, affiliation){
  
  affiliation <- tolower(affiliation)
  if (affiliation == 'lter'){
    key <- paste0('uid=', user.id, ',o=LTER',
                  ',dc=edirepository,dc=org')
  } else if (affiliation == 'edi'){
    key <- paste0('uid=', user.id, ',o=EDI',
                  ',dc=edirepository,dc=org')
  }
  
  key
  
}








#' Collapse EML node to string then compare
#'
#' @param newest (xml_document, xml_node) Newest version of an EML document
#' @param previous (xml_document, xml_node) Previous version of an EML document
#' @param xpath (character) xpath of node to compare
#'
#' @return (character) xpath of node if \code{newest} and \code{previous} differ, otherwise NULL
#' 
compare_node_as_string <- function(newest, previous, xpath) {
  
  # Collapse to string
  newest <- xml2::xml_text(xml2::xml_find_all(newest, xpath))
  previous <- xml2::xml_text(xml2::xml_find_all(previous, xpath))
  
  # Only return dissimilar nodes. Add node number to xpath for exact reference.
  if (!all(newest == previous)) {
    nodes <- which(!(newest == previous))
    if (stringr::str_detect(xpath, "dataTable")) {
      parts <- stringr::str_split(xpath, "(?<=dataTable)")
      res <- paste0(parts[[1]][1], "[", nodes, "]", parts[[1]][2])
      return(res)
    } else if (stringr::str_detect(xpath, "otherEntity")) {
      parts <- stringr::str_split(xpath, "(?<=otherEntity)")
      res <- paste0(parts[[1]][1], "[", nodes, "]", parts[[1]][2])
      return(res)
    } else {
      res <- xpath
      return(res)
    }
  }
  
}








#' Convert missing value codes to NA
#'
#' @param v Vector of values
#' @param code (character) Missing value code
#' @param type (character) Type (class) \code{v} should be. Supported types are: "character", "numeric", "datetime"
#'
#' @return Vector of values with \code{code} replaced by NA in the class of \code{type}
#'
convert_missing_value <- function(v, code, type) {
  if (type == "character") {
    res <- stringr::str_replace_all(as.character(v), paste(code, collapse = "|"), NA_character_)
  } else if (type == "numeric") {
    res <- stringr::str_replace_all(as.character(v), paste(code, collapse = "|"), NA_character_)
    res <- as.numeric(res)
  } else if (type == "datetime") {
    # TODO: Parse datetime according to date time format specifier
    res <- v
  }
  return(res)
}








#' Get the first data package in the staging environment for testing
#' 
#' @param parsed (logical) Return parsed scope, identifier, and revision. Default is TRUE.
#' 
#' @return (character) Data package scope, identifier, and revision
#' 
get_test_package <- function(parsed = TRUE) {
  id <- list_data_package_identifiers("edi", "staging")[1]
  rev <- list_data_package_revisions("edi", id[1], "newest", "staging")
  if (isTRUE(parsed)) {
    r <- list(scope = "edi", id = id, rev = rev)
    return(r)
  } else {
    r <- paste(c("edi", id, rev), collapse = ".")
    return(r)
  }
}








#' Parse package ID into scope, identifier, and revision
#'
#' @param package.id (character) Data packageId
#'
#' @return (list) Data package scope, identifier, and revision
#' 
parse_packageId <- function(package.id) {
  parts <- unlist(strsplit(package.id, ".", fixed = TRUE))
  res <- list(scope = parts[1], id = parts[2], rev = parts[3])
  return(res)
}









#' Polling loop for reserving package IDs
#'
#' @description
#'     Polling loop for reserving package IDs.
#'
#' @usage poll_pkg_reserve_id(r)
#'
#' @param r
#'     (response) Response generated by `httr::POST`.
#'
#' @return
#'     (character) Package identifier.
#'
#'
poll_pkg_reserve_id <- function(r){
  while (TRUE){
    Sys.sleep(2)
    if (r$status_code == '201'){
      reserved_pkg_id <- httr::content(r, as = 'text', encoding = 'UTF-8')
      return(reserved_pkg_id)
      break
    } else if (r$status_code == '401'){
      stop('You are not authorized to create subscriptions.')
      break
    } else if (r$status_code == '400'){
      stop('Request entity contains an error.')
      break
    }
  }
}








#' Set EDIutils user agent for http requests
#' 
#' @return (request) EDIutils user agent
#' 
set_user_agent <- function() {
  res <- httr::user_agent("https://github.com/EDIorg/EDIutils")
  return(res)
}








#' Make URL for PASTA+ environment
#'
#' @description
#'     Create the URL suffix to the PASTA+ environment specified by the
#'     environment argument.
#'
#' @usage url_env(environment)
#'
#' @param environment
#'     (character) Data repository environment to perform the evaluation in.
#'     Can be: 'development', 'staging', 'production'.
#'
url_env <- function(environment){
  
  environment <- tolower(environment)
  if (environment == 'development'){
    url_env <- 'https://pasta-d'
  } else if (environment == 'staging'){
    url_env <- 'https://pasta-s'
  } else if (environment == 'production'){
    url_env <- 'https://pasta'
  }
  
  url_env
  
}








#' Convert minimally nested XML to data.frame
#'
#' @param xml (xml_document xml_node) XML with one level of nesting
#' 
#' @return (data.frame) A data.frame of \code{xml}
#' 
xml2df <- function(xml) {
  lst <- xml2::as_list(xml)[[1]]
  df <- data.frame(
    matrix(unlist(lst), ncol = max(lengths(lst)), byrow = TRUE))
  names(df) <- names(lst[[which(lengths(lst) > 0)[1]]])
  return(df)
}